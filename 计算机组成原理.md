# P26 08:55

# 计算机系统概述

## 计算机体系结构与计算机组成原理

**计算机体系结构**

如何设计硬件与软件之间的接口。例如：有无乘法指令）

机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性(指令系统、数据类型寻术、I/O机理)

**计算机组成原理**

如何用硬件实现所定义的接口（例如：如何实现乘法指令）

实现计算机体系结构所体现的属性，对程序员“<u>透明（不可见的）</u>”(具体指的实现)

## 计算机基础概念

### 存储单位

1KB=2<sup>10</sup>B，1MB=2<sup>20</sup>B，1GB=2<sup>30</sup>B，1TB=2<sup>40</sup>B

1Byte=8bit

###  模2除

其实就是两边同时约定一个除数，发送方添加余数位待接收后通过取余检验是否为0。这里不过是变二进制形式而已。

### 模2减



### 逻辑运算

![1678255476197](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678255476197.png)

## 电路元件

### 译码器

**译码器与芯片配合使用⬇：**

![image-20230410100643497](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410100643497.png)

 

## 计算机系统

- 计算机系统=硬件+软件
- 计算机性能的好坏取决于“软”、“硬”件功能的综合

### 软件

- 计算机的实体
- 如主机、外设等

#### 系统软件

- 用来管理整个计算机系统
- 如操作系统、数据库管理系统(DBMS)、标准程序库、网络软件、语言处理程序、服务程序

#### 应用软件

- 按任务需要编制成的各种程序
- 如：抖音、王者荣耀、迅雷、美图秀秀

### 硬件

- 
  由具有各类特殊功能的程序组成

#### 发展

1947年，贝尔实验室，发明了“晶体管”

1955年，肖克利在硅谷创建肖克利实验室股份有限公司

1957年，八叛徒(traitorous eight) 创立仙童半导体公司。

1959年，仙童半导体公司发明“集成电路

1968年，摩尔等人离开仙童，创立Intel

1969年，仙童销售部负责人桑德斯离开仙童，创立AMD

##### 第一代

第一台电子数字计算机：ENIAC（1946）

逻辑元件：电子管（1.8W个）

##### 第二代

逻辑元件：晶体管

出现面向过程的程序设计语言：FOERTRAN

##### 第三代

逻辑元件：中小规模集成电路

##### 第四代

逻辑元件：大规模、超大规模继承电路时代

出现“微处理器”、微型计算机、个人计算机

#### 微处理器

机器字长：计算机次整数运算所能!处理的二进制位数

微型计算机的发展以微处理器技术为标志



## 硬件结构

### 冯诺依曼结构

- 存储程序概念：**将指令以二进制代码的形式事先输入计算机的主存储器**。然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
- 在计算机系统中，**软件和硬件在逻辑上是等效的**
  Eg：对于乘法运算，可以设计一个专门的硬件电路实现乘法运算；也可以用软件的方式，执行多次加法运算来实现
- 冯·诺依曼计算机的特点：
  1、计算机由五大部件组成
  2、指令和数据以同等地位存于存储器，可按地址寻访
  3、指令和数据用二进制表示
  4、指令由操作码和地址码组成
  5、存储程序（<u>如上解释</u>）
  6、**以运算器为中心**（输入/输出设备与存储器之间的数据传送通过运算器完成）

![屏幕截图 2023-02-19 112859](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-02-19%20112859.png)

### 现代计算机结构

![1676777955421](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676777955421.png)

![1676778345132](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676778345132.png)

- CPU=运算器+控制器
- 现代计算机**以存储器为中心**
- 主机和机箱不是一个东西。

- 主存就是内存，辅存是外存。

## 硬件部件

### 运算器

![1676792691376](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676792691376.png)

- 运算器用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）
- ACC（Accumulator）：累加器，用于存放操作数，或运算结果。
  MQ（Multiple-Quotient Register）：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果
  X：通用的操作数寄存器，用于存放操作数
  **ALU**（Arithmetic and Logic Unit）：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算

### 控制器

![1676793661046](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676793661046.png)

- **CU**（Control Unit）：控制单元，分指给出控制信号
  IR（Instruction Register）：指令寄存器，存放当前执行的指令
  **PC**（Program Counter）：程序计数器，存放下一条指令地址，有自动加1功能
- 完成一条指令的步骤：PC取指令--->IR分析指令--->CU执行指令（其中PC和IR取和分析指令的步骤称为“取指”）



## 硬件工作过程

![1676795604717](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676795604717.png)

！！！操作例子（动手多练）：

![1676795752155](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676795752155.png)



## 层次结构

![1676796113682](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676796113682.png)

- 下层是上层的基础，上层是下层的扩展

## 程序语言

![1676796352177](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676796352177.png)

- 编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序(只需翻译一次)。类似文本翻译。
- 解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句(每次执行都要翻译)。类似同声传译。
- 注：编译、汇编、解释程序，可统称为“翻译程序”。



## 性能指标



### CPU（运算器+控制器）

![1676802956125](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676802956125.png)

- CPU时钟周期，单位为微秒、纳秒等。
  <u>CPU时钟周期=1/CPU主频（时钟频率）</u>
- **CPU主频**为CPU内数字脉冲信号振荡的频率，单位为赫兹（Hz）
  <u>CPU主频（时钟频率）=1/CPU时钟周期</u>
  Eg：主频为10Hz，表示每秒有10个脉冲信号。
- **CPI**（Clock cycle Per Instruction）指执行一条指令所需的时钟周期数。不同的指令，CPI不同。甚至相同的指令，CPI也可能有变化。
- <u>执行一条指令的耗时=CPI*CPU时钟周期</u>
- <u>执行整个程序的耗时（CPU执行时间）=CPU时钟周期/主频</u>
      <u>=（指令条数*CPI）/主频</u>
- IPS (Instructions Per Second )：每秒执行多少条指令，单位为KIPS、MIPS等（注意此处的KMGT为数量单位，即K=Kilo=千=10<sup>3</sup>,M=million=百万=10<sup>6</sup>，G=Giga=十亿=10<sup>9</sup>，T=Tera=万亿=10<sup>12</sup>）
  <u>IPS=主频/平均CPI</u>
- FLOPS（Floating-point Operations Per Second）：每秒执行多少次浮点运算，单位为KFLOPS、MFLOPS、GFLOPS、TFLOPS（此处的K、M、G、T为数量单位）
- 关于K、M、G、T：描述容量、文件大小等，则是2的n次方；描述数据处理速率等，则是数量单位。

例题：

![1676804114606](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676804114606.png)

### 系统整体

- 数据通路带宽：数据总线一次所能并行传送信息的位数(各硬件部件通过数据总线传输数据)
- 吞吐量：指系统在单位时间内处理请求的数量。
  它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。
- 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。
  通常包括CPU时间(运行一个程序所花费的时间)与等待时间(用于磁访问、存储器访问、I/O操作、操作系统开销等时间)
- 基准程序（动态测试）：用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。（=跑分程序）



# 数据的表示和运算

## 进位计数制

### r进制计数法

- 基数：每个数码位所用到的不同符号的个数，r进制的基数是r

### 二进制<-->八进制

**二进制-->八进制**：3位一组，每组转换成八进制符号。

- 二进制r=2，数位有两种可能；八进制r=8，数位有八种可能。取三位二进制的数，则有2\*2\*2=8种可能

Eg：

![1676964827774](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676964827774.png)

**八进制-->二进制**：每位八进制对应3位二进制

Eg：

![1676965051450](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676965051450.png)

### 二进制<-->十六进制

**二进制-->十六进制**：4位一组，每组转换成十六进制符号。

- 二进制r=2，数位有两种可能；十六进制r=16，数位有十六种可能。取四位二进制的数，则有2\*2\*2\*2=8种可能

Eg：

![image-20230221153617318](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230221153617318.png)

**十六进制-->二进制**：每位十六进制对应4位二进制

Eg：

![1676965081266](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676965081266.png)

### 十进制-->任意进制

理论及其推导过程（需要分为整数和小数部分）

 ![1676965376084](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676965376084.png)

![1676965625279](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676965625279.png)

![1676965662688](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676965662688.png)

还有种方法是拼凑法。

### 真值和机器数

- 真值：符合人类习惯的数字
- 机器数：数字实际存到机器里的形式，正负号需要被“数字化”



## BCD码

- BCD（Binary-Coded Decimal）：用二进制编码的十进制
- 4位二进制数有16种可能，将其中的10种可能，分别映射到0-9的一位十进制数的这10种可能。（用4位二进制数来存储1位十进制数）
- 映射方案不同，映射关系、映射表也不同。

### 8421码

![1676966109020](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676966109020.png)

#### 加法机制

- 相加后的数若在合法范围内，则不需要修正。

- 相加后的数若不在映射表中，则需要再进行+0110（+6）的操作。
  原因：4位的二进制数有16种可能，而1位十进制数则只有10种可能，那么转换过程中，有可能会出现十进制数中不曾出现的其他6中可能（即不在映射表中），此时的数是以十六进制的数存在的，+6（+0110）是为了从十六进制转成十进制。

  （网友解释观点：4个bit位表示的应该是十六进制，而BCD码规定4个bit位表示十进制，这就多了10-15 这6个BCD码表示不出（BCD就是想要十进制），所以落这个区间加6，十六进制刚好进1，个位不变，）

Eg：

![image-20230221160632057](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230221160632057.png)

###  余3码

- 8421码+0011（+3）

![1676966985094](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676966985094.png)

### 2421码

- 权值：2421分别对应每一位的权值
- 0-4最高位都是0，5-9最高位都是1

![1676967071174](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676967071174.png)

## 字符和字符串

### 英文字符

#### ASCII码

- 常用字符为128个-->7位二进制编码，高位补零-->8位二进制码
- ASCII码表中可印刷字符为32-126，其余为控制和通信字符。
- 数字字符（48-57）规律：二进制表示中，前四位都为0011，后四位是用8421码映射。
  Eg：48 --> (0011 0000)<sub>2</sub>  57 --> (0011 1001)<sub>2</sub>
- 小写字母（65-90）规律：二进制表示中，前三位都为010，后五位是1~26用8421码映射（26个英文字母）。
  Eg：65 --> (0100 0001)<sub>2</sub>  90 --> (0101 1010)<sub>2</sub>
- 大写字母（97-122）规律：二进制表示中，前三位都为011，后五位是1~26用8421码映射（26个英文字母）。
  Eg：97 --> (0110 0001)<sub>2</sub>  90 --> (0111 1010)<sub>2</sub>

例题：

![1676967989438](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676967989438.png)

### 中文字符

#### GB 2312-80

- GB 2312为国家设计的汉字编码方式。
- GB 2312-80是1980s出的，汉字+各种符号共7445个
- 94个区，每区94个位置（对应表格的位置）

#### 区位码


GB 2312+20H

#### 国标码

区位码+2020H

#### 汉字内码



#### 机内码



国标码和汉子内码是两套编码

因为国标码之所以叫国标码，是因为只有汉字，我们国家自己用的，里面没有英文字母，汉字内码为了加上英文并且区别于国标码就要在国标码基础上，所以不直接+128

加80H为是了2个8bit的最高位为1，与ASCII码区别开，因为2个8bit最高位为1就不会被翻译成ACSII码

汉字是8bit+8bit   前面加20H为了从32开始，与控制/通信字符区别开

![1676968556985](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676968556985.png)

### 字符串

![1677397558062](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677397558062.png)

![image-20230226154742756](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230226154742756.png)



大端模式：低地址 -----------------> 高地址
Eg：0x12  |  0x34  |  0x56  |  0x78

小端模式： 低地址 ------------------> 高地址
Eg：0x78  |  0x56  |  0x34  |  0x12

大端模式和字符串的存储模式类似。



## 奇欧校验

### 校验原理

- 计算机信息传递的时候会出现位错误。
- 码字：若干位代码组成的一个字。
- 两个码字间的距离：将两个码字逐位进行对比，具有不同的位的个数。
- 码距：一种编码方案可能有若干个合法码字，各合法码字间的最小距离。
- 当d=1时，无检错能力;当d=2时，有检错能力；当d>3时，若设计合理,可能具有检错、纠错能力（例如海明码）

### 奇偶校验码

- 奇校验码:整个校验码（有效信息位和校验位）中“1”的个数为偶数。
- 偶校验码:整个校验码（有效信息位和校验位）中“1”的个数为奇数。

![1677398378521](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677398378521.png)

- 偶校验的硬件实现：各信息进行异或(模2加)运算，得到的结果即为偶校验位

Eg：

![1677398749785](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677398749785.png)

![1677398774175](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677398774175.png)

### 海明校验码

- <u>偶校验只能发现奇数位的错误，但无法确定是哪一位出错</u>（1个校验码只能携带对/错这两种状态信息）
- 设计思路：将信息位分组进行偶校验，则有多个校验位，则可以通过多个校验位标注出错位置
- 具有1位的纠错能力，2位的检错能力 

#### 求解步骤

Eg：信息位 1010

##### **确定校验位数量**

![1677399107283](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677399107283.png)

![1677400354184](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677400354184.png)

##### **确定校验位的分布**

解释1：海明码的校验位就是用来把二进制编码，像2,4,8这样只有1个1的位置给堵了

解释2：选1248的原因是为了构造剩下的3567的二进制从列看线性无关，从而能够校验出哪一位出错

![1677400437057](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677400437057.png)

##### **求校验位的值**

将信息位的位置的值用二进制表达出来

![1677400656010](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677400656010.png)

##### **检错纠错**

当它们的异或结果为0，代表没有出错，为1便代表有问题。

校验位是对应的三个信息位异或结果，因此想要纠错只要让校验位与对应的三个信息位再进行一次异或运算。

![1677401023780](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677401023780.png)

![1677400205095](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677400205095.png)

#### 全校验

- 为了区分1位错和2位错，还需添加“全校验位”对整体进行偶校验

![1677401440858](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677401440858.png)



### 循环冗余校验码（CRC码）

- 数据发送、接受方约定一个“除数”。

- K个信息位+R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。收到数据后，进行除法检查余数是否为0。若余数非0说明出错，则进行重传或纠错

![1677401851769](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1677401851769.png)

模二其实相当于二进制的意思，学过一点数字电路就很好理解了，数电会让你设计完成这样子功能的逻辑电路，在这里的运算是将进位及借位不考虑之后的结果。

## 定点数

### 定点整数

![1678253489704](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678253489704.png)



### 定点小数





### 原码



#### 加减运算

![1678254868228](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678254868228.png)



### 补码



#### 单符号位补码（模2补码）

 

#### 双符号位补码（模4补码）



### 反码



### 移位运算

#### 算数移位（补码）

- 正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。
  右移:高位补0，低位舍弃。
  左移:低位补0，高位舍弃。
- 负数补码=反码末位+1导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。
  右移(同反码):高位补1，低位舍弃。
  左移(同原码):低位补0，高位舍弃。
- 规律：负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码

![1678254088027](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678254088027.png)

![1678254114872](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678254114872.png)

Eg：

![1678254193191](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678254193191.png)

#### 逻辑移位

举例：

![1678254430993](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678254430993.png)

#### 循环移位

便于实现高低字节的运算。  



### 加法运算

#### 溢出判断

![1678255314563](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678255314563.png)

判断方法一：

![1678255583381](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678255583381.png)

判断方法二：

![image-20230308140846699](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230308140846699.png)

对于两负数相加，必然产生符号位进位位，而如果最高位数不产生进位位1，那么符号位就会变为0。即负加负结果为正。

判断方法三：

![1678255869683](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678255869683.png)





[(83条消息) 补码的加减运算和溢出判断_补码加减_普鲁士程序员的博客-CSDN博客](https://blog.csdn.net/Lkskywalker/article/details/123307031)



#### 符号扩展

![image-20230308141715280](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230308141715280.png)



### 乘法运算

#### 乘法原理

十进制：

![1678256549385](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678256549385.png)

二进制：

![image-20230308142415311](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230308142415311.png)

#### 实现原理

##### 原码一位乘法

实现方法：先加法再移位，重复n次

机器实现：

![image-20230308183156587](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230308183156587.png)

##### 补码一位乘法（Booth算法）

![image-20230308183945337](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308183945337.png)

##### 原码、补码乘法对比

![1678272125926](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678272125926.png)

### 除法运算

#### 除法原理

![1678272227634](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678272227634.png)

![1678272412754](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678272412754.png)

规律:忽略小数点，每确定一位商，进行一次减法，得到4位余数，在余数末尾补0，再确定下一位商。确定5位商即可停止(机器字长为5位)

#### 实现原理

![image-20230308184952664](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230308184952664.png)

##### 原码除法：恢复余数法

实现方法：上商0/1，得到余数，余数末尾补0。

用[Y]补的原因：A-B为正，所以[A-B]=[A-B]补=[A]+[-B]补。没有或者说不方便做减法运算，通过加法运算代替减法运算。运算一般

求余数：(ACC)-([Y]补、除数)-->ACC

判断余数：若余数是负数，说明应该上商0，后恢复余数。

恢复余数：(ACC)+([Y]补、除数)-->ACC

![1678274412333](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1678274412333.png)



##### 原码除法：加减交替法（不恢复余数法）

优化过程：

![image-20230308192147891](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308192147891.png)

![image-20230308192743823](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308192743823.png)

##### 原码除法对比

![image-20230308192535265](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308192535265.png)



##### 补码除法：加减交替法

![image-20230308193353355](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308193353355.png)

#### 总结

![image-20230308193515367](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308193515367.png)



### 强制类型转换

无符号数与有符号数：不改变数据内容，改变解释方式。

长整数变短整数：高位截断，保留低位。

短整数变长整数：符号扩展

![image-20230308193919136](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308193919136.png)



### 数据存储和排列

#### 大小端模式

![image-20230308194659114](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308194659114.png)

#### 边界对齐

![image-20230308195621972](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230308195621972.png)

字节和半字节的寻址：运用给出的字节的首个byte的地址，进行移位运算到需要的位置

Eg：假设存储字长为32位，则1个字=32bit，半字=16bit。每次访存只能读/写1个字。

此时的字和字节的转换中，右移两位。例如：2号字对应的地址就是1000



## 浮点数

### 浮点数的表示

![image-20230313092103550](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313092103550.png)

### 浮点数标准（IEEE 745）

![image-20230313093514353](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230313093514353.png)

### 浮点数的运算

#### 加减运算

阶数小的向阶数大的靠齐，即阶数小的要右移（计算机内部尾数是定点小数，尾数左移可能引起最高有效位丢失，而右移只是丢失精度）







## 强制类型转换







## 算术逻辑单元

### 基本单元

![image-20230313143448871](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230313143448871.png)

![image-20230313143343066](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313143343066.png)

Eg：

![image-20230313143532337](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313143532337.png)



### 应用

#### 门电路求偶校验位

逻辑表达式是对电路的数学化描述

![image-20230313143827278](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313143827278.png)



#### 加法器实现

##### 一位全加器

![image-20230313144340761](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313144340761.png)

#####  串行加法器

串行加法器：只有一个全加器，数据逐位串行送入加法器中进行运算。
进位触发器用来寄存进位信号，以便参与下一次运算。

如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器。

![image-20230313144525894](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313144525894.png)

##### 并行加法器

![image-20230313144717525](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313144717525.png)





#### 优化

思路：第i位向更高位的进位 C可根据 被加数、加数的第 i 位,再结合即可确定

![image-20230313145135182](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313145135182.png)

##### 并行加法器优化

![image-20230313152317251](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313152317251.png)

![image-20230313152413201](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313152413201.png)

![image-20230313152439765](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313152439765.png)

##### ALU芯片优化

![image-20230313152503359](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230313152503359.png)



## 存储系统

### 主存储器结构

![1676778896536](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676778896536.png)

- 存储体所有的存储数据。
- MAR暂时存储（寄存）数据的地址。
- MDR暂时存储（寄存）数据。

#### 存储体

![1676792281834](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerComposition1676792281834.png)

- 存储单元：每个存储单元存放一串二进制代码
  存储字(word)：存储单元中二进制代码的组合
  存储字长：存储单元中二进制代码的位数
  存储元：即存储二进制的电子元件，每个存储元可存 1bit
  （即：**存储单位中存储的是存储字，存储字的长度叫做存储字长，存储元则是一个计量单位，1bit为一个存储元。**）
- 例如：
  MAR=4位   --->总有 2<sup>4</sup>个存储单元
  MDR=16位 --->每个存储单元可存放16bit，
                            1个<u>字</u>(word) = 16bit

- 1个<u>字节</u>（Byte）=6bit
  1B=1个字节
  1b=1个bit
  1个字（word）大小取决于硬件的设计



### 存储器

#### 层次化结构

![image-20230314161838359](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230314161838359.png)



![image-20230314161127969](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230314161127969.png)

![image-20230314161444527](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230314161444527.png)

辅存中的数据要调入主存后才能被CPU访问

CPU运行过快，有的时候主存会将被频繁使用的程序复制一份到Cache

主存一辅存：实现虚拟存储系解决了王存容量不够的问题

Cache一主存：解决了主存与CPU速度不匹配的问题

#### 存储介质

半导体存储器：以半导体件存储信息（主存、Cache）

磁表面存储器：以磁性材料存储信息（磁盘、磁带）

光存储器：以光介质存储信息

#### 存储方式

随机存取存储器(RandomAccess Memory, RAM)：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关

顺序存取存储器(SequentialAccess Memory，SAM)：读写一个存储单元所需时间取决于存储单元所在的物理位置

直接存取存储器 (Direct AccessMemory，DAM):既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取

串行访问存储器：读写某个存诸单元所需时间，与存储单元的物理位置有关（如随机存取存储器、顺序存取存储器）

相联存储器Associative Memory）：即可以按内容访问的存储器ContentAddressed Memory，CAM）可以按照内容检索到子储位置进行读写，“快表”就是一种相联存储器

#### 信息可改性

读写存储器(Read/Write Memory)：即可读、也可写(如:磁盘、内存、Cache)

只读存储器(Read Only Memory)：只能读，不能写(如:实体音乐专辑通常采用 CD-ROM实体电影采用蓝光光碟，BIOS通常写在ROM中)

事实上很多ROM也可多次读写，只是比较麻烦

#### 信息可保存性

断电后，存储信息消失的存储器一一易失性存储器 (主存、Cache)

断电后，存储信息依然保持的存储器一一非易失性存储器(磁盘、光盘)

信息读出后，原存储信息被破坏-一破坏性读出(如DRAM芯片，读出数据后要进行重写)

信息读出后，原存储信息不被破坏一一非破坏性读出 (如SRAM芯片、磁盘、光盘)

### 性能指标

存储容量：存储字数X字长(如1M*8位)MDR位数反映存储字长

总容量 = 存储单元个数x存储字长 bit
             = 存储单元个数x存储字长/8 Byte

（1Byte = 8bit）

单位成本：每价格=总成本/总容量。

存储速度：<u>**数据传输率**</u>=数据的宽度/存储周期。

![image-20230314163237665](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230314163237665.png)

<u>**存储周期=**</u>存取时间+恢复时间

存取时间（Ta）：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。

存取周期（Tm）：存取周期又为读写周期或访问周期。它是指储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作(读或写操作)之间所需的最小时间间隔。

主存带宽（Bm）：主存带宽文称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、宁节/秒 (B/s)或位/秒 (b/s)

### 主存储器的基本组成

#### 半导体元件及其原理

![image-20230314163820277](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230314163820277.png)

MOS管：可理解为一种电控开关，输入电压达到某个闽值时，MOS管就可以接通

 ![image-20230314164507256](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230314164507256.png)

存储字长不一定是8bit

1个字（word）大小取决于硬件的设计



#### 存储器芯片

##### 基本原理

![image-20230314165904759](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230314165904759.png)

译码器：会根据MAR（地址寄存器）转换成某一条字选线的高电平信号

控制电路：会根据MAR和MDR电路是否稳定来进行下一步送出数据

地址总线、数据总线都和CPU连接

片选线：通常用<u>CS上划线</u>（chip select 芯片选择信号）和<u>CE上划线</u>（chip enable 芯片使能信号）表示其电信号。（头上划线表示该信号低电平有效）

读、写控制线有两种设置方法，可以一根也可以两根。



##### 整体图

![image-20230314170352263](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230314170352263.png)

金属引脚：每根线对应一个金属引脚。另外还有供电引脚、接地引脚。

n位地址-->2<sup>n</sup>个存储单元

总容量 = 存储单元个数x存储字长
             = 2<sup>3</sup> *8bit = 2<sup>3</sup> *1Byte = 8B

8 x 8位的存储芯片常见的描述：
8K x 8位，即2<sup>13</sup> *8bit
8K x 1位，即2<sup>13</sup> *1bit
64K x 16位，即2<sup>16</sup> *16bit



##### 寻址

Eg：

![image-20230314171608760](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230314171608760.png)

地址线：2<sup>10</sup>=1K

字地址左移两位，即可变成字节地址

### RAM

RAM芯片一一易失性，断电后数据消失

DRAM芯片：使用极电容存储信息

SRAM芯片：使用双稳态触发器存储信息

#### DRAM

1:电容内存了电

0:电容内未存储电荷

读出1: MOS管接通，电容放电，数据线上产生电流

读出0: MOS管接通后，数据线上无电流

![image-20230410083820015](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410083820015.png)



电容放电信息被破坏，是破坏性读出。

读出后应有重写操作，也称“再生”。

读写速度更慢。

每个存储元制造成本更低，集成度高,功低

##### 刷新

电容内的电荷只能维持2ms。即便不断电，2ms后信息也会消失

![image-20230410090812347](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410090812347.png)

一行存储单元⬇：

![image-20230410084952689](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410084952689.png)

刷新时刻⬇：

![image-20230410090754875](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410090754875.png)

##### 地址线复用技术

![image-20230410091012830](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410091012830.png)





#### SRAM

双稳态：1: A高B低      0: A低B高

![image-20230410084207685](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410084207685.png)

读出数据，触发器状态保持稳定，是非破坏性读出，无需重写。

读写速度更快。

每个存储元制造成本更高，集成度低，功耗大。

#### 对比

![image-20230410091124788](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410091124788.png)



### ROM

很多ROM芯片虽然名字是“Read-Only”，但很多ROM也可以“写”

ROM芯片是非易失性的。

很多ROM也具有“随机存取”的特性

#### 各类ROM

MROM（Mask Read-Only Memory）：掩模式只读存储器
厂家家按照客户需求，在芯片生产过程中直接写入信息，之后<u>任何人不可重写</u>(只能读出)
可靠性高、灵活性差、生产周期长、只适合批量定制

PROM(Psogrammable Read-Only Memory)：可编程只读存储器
用户可用专门的PROM写入器写入信息，<u>写一次之后就不可更改</u>

EPROM(Erasable Programmable Read-Only Memory)：可擦除可编程
只读存储器允许用户写入信息，之后用某种方法擦除数据，可进行多次重写
UVEPROM (ultraviolet rays)：用紫外线照射8~20分钟，擦除<u>所有</u>信息
EEPROM (也常记为E<sup>2</sup>PROM，第一个E是Electrically)：可用“电擦除”的方式，擦除<u>特定的字</u>

Flash Memory：闪速存储器(注: U盘、SD卡就是闪存、每个存储元只需个MOS管，位密度比RAM高)
在EEPROM 基础上发展而来，断电后也能保存信息，且可进行多次快速擦除重写
注意:由于闪存需要先擦除在写入，因此<u>闪存的“写”速度要比“读”速度更慢</u>

SSD( Solid State Drives)：固态硬盘（手机辅存也使用Flash 芯片，但相比SSD使用的芯片集成度高、功耗低、价格贵）
由控制单元+存储单元 (Flash 芯片)构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，<u>可进行多次快速擦除重写</u>。SSD速度快、功耗低、价格高。目前个人电脑上常用SSD取代传统的机械硬盘

#### BIOS

主板上的BIOS芯片 (ROM) 存储了“自举装入程序”，负责引导装入操作系统 (开机)

逻辑上，主存由RAM+ROM组成，且二者常统一编址

注:我们常说“内存条”就是“主存”，但事实上，主板上的ROM芯片也是“主存”的一部分

![image-20230410092129040](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410092129040.png)

#### 主存速度提升

**存取周期T=存取时间r+恢复时间**

DRAM芯片的恢复时间（见村粗系统）比较长，有可能是存取时间的几倍 （SRAM的恢复时间较短）

多核CPU都要访存，怎么办?——双口RAM

CPU的读写速度比主存快很多，主存恢复时间太长怎么办?——多模块存储器

##### 双端口RAM

![image-20230410102547109](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410102547109.png)

需要有两组完全独立的数据线、地址线、控制线。CPU、RAM中也要有更复杂的控制电路

作用：优化多核CPU访问一根内存条的速度

两个端口对同一主存操作有以下4种情况：（对比操作系统，读者-写者问题）

1.两个端口同时对不同的地址单元存取数据。√

2.两个端口同时对同一地址单元读出数据。√

3.两个端口同时对同一地址单元写入数据图。<u>×写入错误</u>

4.两个端口同时对同一地址单元，一个写入数据，另一个读出数据。<u>×读出错误</u>

解决方法：置“忙”信号为0,由图断逻辑央定暂时关闭一个端口 (即被延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。



##### 多模块存储器（多体并行存储器）

高位交叉编址：采用内存地址的高几位比特位，区分访问哪个存储体。

低位交叉编址：采用内存地址的低几位比特位，区分访问哪个存储体。

⬇M0、M1、M2、M3可理解为四根内存条。

![image-20230410103626069](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410103626069.png)

取n个存储字，耗时为nr+3r⬆

连续访问：大多数数据存储的地址是连续的。⬆



**Q：应该取几个“体”？**

采用“流水线”的方式并行存取(宏观上并行，微观上串行)

宏观上，一个存储周期内，m体交叉存储器可以提供的数据量为单个模块的m倍。

存取周期为T，存取时间为r（总线传输周期为r），为了使流水线不间断，应保证模块数 m≥T/r⬇

![image-20230410104248890](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410104248890.png)

**Q：给定地址X，如何判断属于第几个存储体？**

m个存储体，

方法一：根据体号判断

方法二：x%m



##### 单体多字存储器

![image-20230410104822504](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410104822504.png)

每个存储单元存储m个字

总线宽度也为m个字

一次并行读出m个字

每次只能同时取m个字，不能单独取其中某个字，指令和数据在主存内必须是连续存的，灵活性较差



##### 双通道内存

![image-20230410105504481](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410105504481.png)

买内存条时，可挑选相同主频、相同容量的两根来组成双通道

相同主频：可以让T和r相同，不会出现高频内存需要降频使用，浪费的情况。

相同容量：组成双通道后，若两内存容量不同，可能导致地址内存一部分为双通道，一部分多余的仍为单通道，使得使用过程中性能不稳定。

将两条相同的内存条插入同样颜色的卡槽中，CPU可以实现低位交叉的多提存储器（俗称“双通道”）。

### Cache

主存优化后速度与CPU差距依然很大，引入Cache。

![image-20230410110348195](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410110348195.png)

实际上，Cache 被集成在CPU内部Cache用SRAM实现，速度快，成本高

#### **局部性原理**

空间局部性：在最近的未来要用到的信息(指令和数)，很可能与现在正在使用的信息在存储空间上是邻近的（例如数组a、顺序执行代码）⬇

时间局部性:在最近的未来要用到的信息，很可能是现在正在使用的信息（例如for循环）⬇

![image-20230410110555978](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410110555978.png)

程序A是按“行优先”访问，空间局限性比较好。若按“列优先”访问，则空间局部性更差，代码执行会更慢。⬆

基于局部性原理，不难想到，可以把CPU目前访问地址“周围”的部分数据放到Cache中

#### 性能分析

命中率H：CPU欲访问的信息已在Cache中的比率
缺失(未命中)率M = 1- H

Cache一主存 系统的平均访问时间t
=Htc+(1 -H)(tc+ tm)（先访问Cache，若Cache未命中再访问主存）
=Htc+(1-H)tm（同时访问 Cache和主存，若Cache命中则立即停止访问主存）

**Eg：**

![image-20230410122354839](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410122354839.png)



#### 其他概念

- **Q：**基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放到Cache中。**如何界定“周围”?**

  <u>主存与Cache之间以“块”为单位进行数据交换</u>。将主存的存储空间“分块”，如：1KB为一块⬇

![image-20230410123658979](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230410123658979.png)



- Cpu会先在cache寻找，找不到再去主存找，而每次被访问的主存块一定会被立即调入Cache

- 操作系统中<u>通常将主存中的“一个块”也称为”一个页/页面/页框”。</u>

- <u>Cache中的“块”也称“行”。</u>

#### Cache与主存映射方式

**引入Q：**如何区分 Cache 与主存的数据块对应关系？

![image-20230410125240492](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410125240492.png)

给每个Cache块增加一个“标记”和“有效位”，记录对应的主存块号⬇

![image-20230410125546771](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410125546771.png)



**前提：**假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行（即Cache块，与主存块的大小相等），行长为64B。

##### 全相联映射（随便放）

优点:Cache存储空间利用充分，命中率高
缺点: 查找“标记”最慢，有可能需要对比所有行的标记

![image-20230410130137760](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410130137760.png)

访存方法⬇

![image-20230410130033440](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410130033440.png)

Eg：CPU 访问主存地址1...1101001110步骤：
1.主存地址的前22位，对比Cache中所有块的标记
2.若记配且有效位=1，则Cache命中，访问块内地址为001110 的单元
3.若未命中或有效位=0，则正常访问主存

##### 直接映射（只能放固定位置）

<u>直接映射：主存块在Cache中的位置=主存块号%Cache总块数</u>

优点:对于任意一个地址，只需对比一个“标记”，速度最快
缺点: Cache存储空间利用不充分，命中率低

优化标记：主存块号%2<sup>3</sup>相当于留下最后三位二进制数。
若Cache总块数=2<sup>n</sup>则主存块号末尾n位直接反映它在Cache中的位置
将主存块号的其余位作为标记即可⬇

![image-20230410141523583](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410141523583.png)

访存方法⬇

![image-20230410141542377](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410141542377.png)

**Eg：**CPU 访问主存地址0..01000 001110 步骤：
1.根据主存块号的后3位确定Cache行
2.若主存块的19位与Cache标记匹配且位=1，Cache命中，访问块内地址为 001110单元。
3.命中有效位=0，则正常访问主存

##### 组相联映射（可放到特定分组）

<u>组相联映射，所属分组=主存块号%分组数</u>

优点:另外两种方式的折中，综合效果较好

n路组相联映射一每n个Cache行为一组

优化标记：主存块号%2<sup>2</sup相当于留下最后两位二进制数⬇

![image-20230410141918822](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410141918822.png)

访存方法⬇

![image-20230410142056447](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230410142056447.png)

**Eg：**CPU 访问主存地址1..1101001110 步骤：
1.根据主存块号的后2位确定所属分组号
2.主存块号的前20位与分组内的某个标记匹配且有效位=1则Cache命中，访问块内地址为 001110的单元。
3.命中有效位=0，则正常访问主存

#### Cache替换算法

**引入Q：**Cache 很小，主存很大。如果Cache满了怎么办?——替换算法

















CPU修改了Cache中的数据副本，如何确保主存中数据母本的一致性?——Cache写策略

















### 存储器和CPU

通常情况下，数据总线(宽度=存储字长)

若数据总线宽度>存储芯片字长，怎么办？——位扩展

若想要扩展主存字数，怎么办？一一字扩展（链接多块存储芯片）

**现在的计算机⬇：**

![image-20230410093458147](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410093458147.png)



#### 单块存储芯片与CPU连接

**输入输出信号规范⬇：**

![image-20230410093708843](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410093708843.png)



#### 多块存储芯片与CPU连接

##### 位扩展法

**增加存储芯片数量，拓展存储器的存储字长，可以同时读/写n位信息⬇：**

![image-20230410094032246](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410094032246.png)

![image-20230410094247766](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410094247766.png)

##### 字扩展法

增加存储芯片数量，改造片选信号，拓展存储器的存储字长。

###### 线选法

（若A14和A13均为1，则数据总线的数据传输会出现冲突）⬇

![image-20230410094706881](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410094706881.png)

###### 片选法

使用一个译码器，处理CPU的高位地址部分。⬇

![image-20230410095019559](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410095019559.png)

CS上划线指低电平（0）有效，故需要在译码器后加非门。⬇

![image-20230410095603941](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410095603941.png)

###### 对比

![image-20230410100029755](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410100029755.png)

##### 字位扩展法

位扩展：两块芯片为一组。字扩展：使用了2-4译码器。⬇

![image-20230410100325838](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230410100325838.png)













## 指令系统

### 指令

![image-20230330085534040](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330085534040.png)

- 指令是指示计算机执行某种操作的命令是计算机运行的最小功能单位。
- 一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。
- 注:一台计算机只能执行自已指令系统中的指令，不能执行其他系统的指令。
- Eg：x86架构、ARM架构

#### 按指令长度分类

- 指令字长:一条指令的总长度(可能会变)
- 机器字长:CPU进行一次整数运算所能处理的二进制数据的位数(通常和ALU直接相关)
- 存储字长:一个存储单元中的二进制代码位数(通常和MDR位数相同)
  半字长指令、单字长指令、双字长指令：指令长度是机器字长的多少倍
- 指令字长会影响取指令所需时间。如:机器字长=存储字长=16bit，则取一条双字长指令需要两次访存
- 定长指令字结构:指令系统中所有指令的长度都相等
- 变长指令字结构:指令系统中各种指令的长度不等

#### 按指令长度分类

- 定长操作码：指令系统中所有指令的操作码长度都相同（控制器的译码电路设计简单，但灵活性较低）
  n位 ->2<sup>n</sup>条指令
- 可变长操作码：指令系统中各指令的操作码长度可变（控制器的译码电路设计复杂，但灵活性较高）
- 扩展操作码指令格式：定长指令字结构+可变长操作码

#### 按操作类型分类

![image-20230328145809748](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328145809748.png)

转移操作本质上改变了PC的值。

#### 按地址指令位数分类

n位地址码的直接寻址范围=2<sup>n</sup>，地址码位数越多，寻址范围越强；

若指令总长度固定不变，则地址码数量越多，寻址能力越差；

##### 零地址指令

##### ![image-20230328143121337](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328143121337.png)

- 不需要操作数，如空操作、停机、关中断等指令两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶

- 堆栈计算机（例如数据结构中的“后缀表达式”），两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。

##### 一地址指令

![image-20230328143158508](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328143158508.png)

- 只需要单操作数，如加1、减1、取、补等
  指令含义:OP(A<sub>1</sub>)->A<sub>1</sub>。
  完成一条指令需要3次访存：取指-读A<sub>1</sub>-写A<sub>1</sub>

- 需要两个操作数，但其中一个操作数隐含在某个寄存器(如隐含在ACC)
  指令含义:(ACC)OP(A<sub>1</sub>)->ACC
  完成一条指令需要2次访存：取指->读A<sub>1</sub>

- 注：A<sub>1</sub>指某个主存地址（类比C语言指针）
         (A<sub>1</sub>)表示A<sub>1</sub>所指的地址中的内容（指针所指位置的内容）

##### 二地址指令

![image-20230328143754364](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328143754364.png)

- 常用于需要两个操作数的算术运算、逻辑运算相关指令
  指令含义:(A<sub>1</sub>)OP(A<sub>2</sub>)->A<sub>1</sub>
  完成一条指令需要访存4次，取指->读A<sub>1</sub> ->读A<sub>2</sub> ->写A<sub>1</sub>

##### 三地址指令

![image-20230328143818088](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328143818088.png)

- 常用于需要两个操作数的算术运算、逻辑运算相关指令
  指令含义:(A<sub>1</sub>)OP(A<sub>2</sub>)->A<sub>3</sub>
  完成一条指令需要访存4次A<sub>1</sub>：取指>读A<sub>1</sub> ->读A<sub>2</sub> ->写A<sub>3</sub>

##### 四地址指令

![image-20230328144245311](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328144245311.png)

- A1-A3同上方三地址指令。

- 正常情况下:取指令之后 PC+1，指向下一条指令
- 四地址指令:执行指令后，将PC的值修改为A<sub>4</sub>所指地址



### 扩展操作码

扩展操作码指令格式：定长指令字结构+可变长操作码

#### 设计原则

![image-20230328150430183](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328150430183.png)

#### 举例

![image-20230328150307160](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328150307160.png)

![image-20230328151108743](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230328151108743.png)

### 指令寻址

**下一条**欲执行**指令**的**地址**(存储在PC中，终由程序计数器PC给出)

#### 顺序寻址

**（PC）+“1”--->PC**（这里的1 理解为1个指令字长，实际加的值会因指令长度、编址方式而不同）

![image-20230330085948667](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330085948667.png)

![image-20230330090112074](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330090112074.png)

![image-20230330090303276](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330090303276.png)



#### 跳跃寻址

由转移指令指出

![image-20230330090639772](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330090639772.png)

执行转移指令，此时会将PC值修改为7.



### 数据寻址

确定**本条指令**的**地址码指明真实地址**

数据寻址讲解：<u>假设指令字长=机器字长=存储字长</u>
                           <u>假设操作数为3</u>

#### 地址码解读

地址码的解读方式有很多种。

![image-20230330091549714](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330091549714.png)

![image-20230330091649180](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330091649180.png)

其他地址都可以参照一地址指令的方式。

Eg：

![image-20230330091116646](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330091116646.png)

此时的“7”，理解为，基于起始地址的偏移量。

![image-20230330091221421](C:\Users\14638\AppData\Roaming\Typora\typora-user-images\image-20230330091221421.png)

此时的“3”，理解为基于PC指向地址的偏移量。

#### 直接寻址

（假设<u>指令字长=机器字长=存储字长、操作数为3</u>）

**指令字中的形式地址A就是操作数的真实地址EA，即<u>EA=A</u>。**
（CPU直接将A给出的地址直接送到MAR（存储器的地址寄存器）中，无需地址转换）

![image-20230330092118879](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330092118879.png)

![image-20230330092307880](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330092307880.png)

- 一条指令的执行：取指令存1次执行指令访存1次暂不考虑存结果共访存2次
- 优点：简单，指令执行阶段仅访问一次主存不需专门计算操作数的地址。
- 缺点：<u>A的位数决定了该指令操作数的寻址范围</u>。操作数的地址不易修改。

#### 间接寻址

（假设<u>指令字长=机器字长=存储字长、操作数为3</u>）

**指令的地址字段给出的形式地址不是操作数的真正地址，而是<u>操作数有效地址</u>，所在的<u>存储单元的地址，也就是操作数地址的地址</u>，即<u>EA=(A)</u>。**（（A）指的是地址A所指向的主存单元的数据）

![image-20230330092753469](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330092753469.png)

![image-20230330092745690](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330092745690.png)

寻址过程中，主存的第一位是0表示此存储单元存储的地址，是这个操作数的存储地址。

- 一条指令的执行：取指令存1次执行指令 访存2次暂不考虑存结果共访存3次
- 优点：可扩大寻址范围(有效地址EA的位数大于形式地址A的位数)。便于编制程序(用间接寻址可以方便地完成子程序返回)。
- 缺点：指令在执行阶段要多次访存(一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存)。

#### 寄存器寻址

（假设<u>指令字长=机器字长=存储字长、操作数为3</u>）

**在指令字中直接给出操作数所在的<u>寄存器编号</u>，即EA =R，其操作数在由R所指的寄存器内。**

![image-20230330093339460](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330093339460.png)

![image-20230330093439839](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230330093439839.png)







- 一条指令的执行:取指令存1次执行指令访存0次暂不考虑存结果共访存1次
- 优点：指令在执行阶段不访问主存，只访问寄存器（CPU中寄存器的数量不多），指令字短且执行速度快，支持向量/矩阵运算
- 缺点：寄存器价格昂贵，计算机中寄存器个数有限



#### 寄存器间接寻址

**寄存器R<sub>i</sub>中给出的不是一个操作数，而是操作数所在主存单元的地址即EA=(R<sub>i</sub>)。**（（R<sub>i</sub>）指第i个寄存器里面的内容，则整个意思是第i个寄存器里面的内容就是有效地址EA）

![image-20230605094325297](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230605094325297.png)



一条指令的执行：取指令访存1次，执行指令访存1次，暂不考虑存结果共访存2次



#### 隐含寻址

**不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。**

![image-20230605094457286](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230605094457286.png)

优点:有利于缩短指令字长。
缺点:需增加存储操作数或隐含地址的硬件。



#### 立即寻址

**形式地址A就是操作数本身，又称为立即数，一般采用补码形式。**

**地址码前打个“#”，表示立即寻址。**

![image-20230605094549295](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230605094549295.png)



一条指令的执行:取指令存1次执行指令 访存0次暂不考虑存结果共访存1次

优点:指令执行阶段不访问主存，指令执行时间最短

缺点:A的位数限制了立即数的范围。如A的位数为n，且立即数采用补码时，可表示的数据范围为-2<sup>n-1</sup>~2<sup>n-1</sup>-1



#### 前六种总结

![image-20230605094843946](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230605094843946.png)



#### 偏移寻址

![image-20230605095216903](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230605095216903.png)

区别在于偏移的“起点”不一样

基址寻址:以程序的起始存放地址作为“起点”

变址寻址:程序员自己决定从哪里作为“起点”

相对寻址:以程序计数器PC所指地址作为“起点

#### 基址寻址

将CPU中**基址寄存器 (BR)**的内容加上指令格式中的形式地址A而形成操作数的有效地址，即**EA=(BR)+A**。

BR——base addressfegister

EA——effective address

![image-20230605095526021](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230605095526021.png)

![image-20230605095614746](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230605095614746.png)

指明寄存器的bit，需要根据通用寄存器总数判断。



优点:便于程序“浮动’，方便实现多道程序并发运行；可扩友寻址范围(基址寄存器的位数大于形式地址A的位数) ;用户不必考虑自已的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序(整个程序在内存里边的浮动)

注：基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变(作为基地址)，形式地址可交作为偏移量)。

当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器但其内容仍由操作系统确定。

#### 变址寻址

**有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和即EA=(IX)+A，其中IX可为变址寄存器(专用)，也可用通用寄存器作为变址寄存器**

X一 index register

![image-20230605100405424](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/HisPic/MyNotes_PrinciplesOfComputerCompositionimage-20230605100405424.png)



变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变(IX作为偏移量)，形式地址A不变 (作为基地址)





#### 相对寻址

